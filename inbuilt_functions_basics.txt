JAVASCRIPTS Inbuilt Functions:

Code : JAVASCRIPT substr concept
var sentence ="I'm priya and having sounds kowledge."
console.log(sentence.substr(0,5)) //(startigIndex, NoOfCharatersWants-->take 1 less)//I'm p
console.log(sentence.substr(2,5)) //m pri
console.log(sentence.substr(2))   //m priya and having sounds kowledge.
console.log(sentence.substr(4))   //priya and having sounds kowledge.
console.log(sentence.substr(-4))  //Negative goes From ending of the string //dge.
console.log(sentence.substr(-5)) //edge.

================================================================================================================================================================================
Code : JAVASCRIPT slice concept i.e, it doesn't change the original array
var sentence ="I'm priya and having sounds kowledge."
console.log(sentence.slice(0,5)) //"I'm p"
console.log(sentence.slice(2,5)) //"m p"
console.log(sentence.slice(2))   //"m priya and having sounds kowledge."
console.log(sentence.slice(4))   //"priya and having sounds kowledge."
console.log(sentence.slice(-4))  //"dge."
console.log(sentence.slice(-5))  //"edge."

var sentence =['a','b','c','d']
console.log(sentence.slice(0,2)) //['a','b']
console.log(sentence) //['a','b','c','d']
================================================================================================================================================================================
Code : JAVASCRIPT splice concept i.e, it changes the original array
var sentence =['a','b','c','d']
console.log(sentence.splice(0,2)) //['a','b']
console.log(sentence) //['c','d']
================================================================================================================================================================================
Code: JAVASCRIPT indexOf concept
 var greeting = "Hello"
console.log(greeting.indexOf("e")) //1
================================================================================================================================================================================
Code: JAVASCRIPT split concept
var name ="Priya Bagde"
console.log(name.split("")) //["P","r","i","y","a"," ","B","a","g","d","e"]
console.log(name.split(" ")) //["Priya","Bagde"]
================================================================================================================================================================================
Code: JAVASCRIPT join concept
var arr = ['a','b','c','d','e']
console.log(arr.join()) //"a,b,c,d,e"
================================================================================================================================================================================
Code: JAVASCRIPT join concept
var arr = ['a','b','c','d','e']
for(var i=0; i<arr.length; i++){
  console.log(arr[i])
}
"a"
"b"
"c"
"d"
"e"
================================================================================================================================================================================
Advance Interview Concepts


1. Closures- 
A closure is the combination of a function and the lexical environment within which that function was declared.
OR
When inner function can have access to the outer function variables and parameter.

The return statement does not execute the inner function - function is only executed only when followed by ()parathesis, but rather than returns the entire
body of the function.

Uses/advantages of closures:
-event handlers
-callback functions
-Encapsulation: can store data in separate store
-Object data privacy
-Module Design Pattern
-Currying
-Functions like once
-memoize
-setTimeouts
-Iterators
-maintaining state in async world

Disadvantages of closures:
1. Creating function inside a function leads to duplicate in memory and cause slowing down the application means use only when required privacy.
2. As long as the clousers are active, the memory can't be garbage collected means if we are using clousers in ten places then untill all the 10 process complete 
it hold the memory and can overcome to set closure to Null.

const outerFunction =(a)=>{
  let b=10;
  const innerFunction =()=>{
    let sum = a+b;
    console.log(sum)
  }
  innerFunction()
}
outerFunction(5)// 15

const outerFunction =(a)=>{
  let b=10;
  const innerFunction =()=>{
    let sum = a+b;
    console.log(sum)
  }
  return innerFunction
}
outerFunction(5) //output : 
 ()=>{
    let sum = a+b;
    console.log(sum)
  }

const outerFunction =(a)=>{
  let b=10;
  const innerFunction =()=>{
    let sum = a+b;
    console.log(sum)
  }
  return innerFunction
}
let inner = outerFunction(5)
console.log(inner)
inner() //15
================================================================================================================================================================================
Prototype: 
Prototype allow to easily define methods to all the instances of object. It stored in the memory once but every object instances can access it.

1. Javascript is a prototype based language, so, whenever we are creating a function using javascript, javascript engine adds a prototype property inside a function,
Prototype property is basically an object (also known as Prototype object), where we can attach methods and properties in a prototype object, which enables all the
other objects to inherit these methods and properties.
2. We are creating prototype in constructor function. All the intances of objects can able to access properties and methods from constuctor function.
3. The prototype is an object that is associated with every functions and objects by default in JavaScript, where function's prototype property is accessible and 
modifiable and object's prototype property (aka attribute) is not visible.
4. object's prototype property is invisible. Use Object.getPrototypeOf(obj) method instead of __proto__ to access prototype object.
5. prototype is useful in keeping only one copy of functions for all the objects (instances).
6. An Object has a prototype. A prototype is also an object. Hence Even it may have its own prototype object. This is referred to as prototype chain.

<A>Several Types:
1. Object.prototype- It is a prototype OBJECT of object(cunstruction function where it will inherit all properties of Object.protorype). 
Prototype Object of Object.prototype is NULL.
2. Array.prototype-Prototype Object of Array.prototype is Object.prototype and Prototype Object of Object.prototype is NULL.
3. Function.prototype
4. Example-
var person = function(name){
   this.name = name;
}
person.prototype.age = 21;
var piya = new person("Piya");
var priya = new person("Priya");
console.log(piya.age) //21
console.log(priya.age) //21

<B>Purpose/Use of prototype:
1) to find properties and methods of an object 
2) to implement inheritance in JavaScript

<C>Difference between Prototype and __proto__:
1. In reality, the only true difference between prototype and __proto__ is that the former is a property of a class constructor, 
   while the latter is a property of a class instance.
2. Instances have __proto__, classes have prototype.
3. Instances of a constructor function use __proto__ to access the prototype property of its constructor function.
4. __proto__ is invisible property of an object. It returns prototype object of a function to which it links to. 
5. __proto__ is Deprecated. 
6. Example:
function Person(name){
    this.name = name
 }; 
var eve = new Person("Eve"); 
eve.__proto__ == Person.prototype //true
eve.prototype  //undefined
7. Example:
function Person() {
    this.name = 'John'
}
// adding property 
Person.prototype.name = 'Peter';
Person.prototype.age = 23
const person1 = new Person();
console.log(person1.name); // John
console.log(person1.age); // 23

================================================================================================================================================================================
CSS Positions:

1. Static: HTML elements are positioned static by default. Static positioned elements are not affected by the top, bottom, left, and right properties. 
   Imapct of margin or padding. Object can't move. it is always positioned according to the normal flow of the page.
2. Relative: Object can move. It is positioned relative to its normal position. If want gap from its actual placed position then use it. It work with left,
   right, top, bottom properties.
3. Fixed: Not allow to scroll up or down. is positioned relative to the viewport, which means it always stays in the same place even if the page is scrolled. 
   The top, right, bottom, and left properties are used to position the element. The element is positioned relative to the browser window
4. Absolute: it is work with relative i.e, w.r.t parent. It is positioned relative to the nearest positioned ancestor (instead of positioned relative to the 
   viewport, like fixed). if an absolute positioned element has no positioned ancestors, it uses the document body, and moves along with page scrolling.
5. Sticky: An element with position: sticky; is positioned based on the user's scroll position. Internet Explorer does not support sticky positioning. 
   You must also specify at least one of top, right, bottom or left for sticky positioning to work. Use for to create menu.

================================================================================================================================================================================
Time based Event:

SetTimeout: 
1. allows us to run a FUNCTION ONCE, after the interval of time
2. setTimeout() executes the passed function after given time. The id_value returned by setTimeout() function is stored in a variable and 
   it‚Äôs passed into the clearTimeout() function to clear the timer. 
3. Syntax- let timerId = setTimeout(function, milliseconds, [arg1], [arg2], ...)
4. Don't make a mistake by adding brackets () after the function otherwise gives undefined and nothing will scheduled.
5. Example-
let timerId = function sayHi(phrase, who) {
  console.log( phrase + who );
}
setTimeout(sayHi, 1000, "Hello", "John"); 

SetInterval:
1. allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval.
2. setInterval() executes the passed function for the given time interval. The number id value returned by setInterval() function is stored 
   in a variable and it‚Äôs passed into the clearInterval() function to clear the interval.
3. Syntax-
4. Example
let timerId = function sayHi(phrase, who) {
  console.log( phrase + who );
}
setInterval(sayHi, 1000, "Hello", "John");

ClearTimeout:
1. This method is used to cancel a setTimeout().  Inside the method you have to reference the timeoutID.
clearTimeout(timerId)

ClearInterval:
1. This method is used to cancel a setInterval().  Inside the method you have to reference the intervalID.
clearInterval(timerId)
================================================================================================================================================================================
Debouncing and Throttling in JavaScript: using in search box, scrolling or resize the widow size
1. Create impact on performance of your website, but also prevent unnecessary API calls and load on the server.
2. Debouncing and throttling techniques are used to limit the number of times a function can execute. ke button click, mouse move, search bar, window scrolling 
   and window resize allow the user to decide when to execute.
3. The main difference between throttling and debouncing is that throttling executes the function at a regular interval, while debouncing executes the function only 
   after some cooling period.
4. Example: If you're scrolling, throttle will slowly call your function while you scroll (every X milliseconds). Debounce will wait until after you're done scrolling 
   to call your function.

Throttling-
Throttling is a technique in which, no matter how many times the user fires the event, the attached function will be executed only once in a given time interval.

Debouncing- 
No matter how many times the user fires the event, the attached function will be executed only after the specified time once the user stops firing the event.
The Debounce technique allow us to ‚Äúgroup‚Äù multiple sequential calls in a single one.
var debounced_version = _.debounce(doSomething, 200);
$(window).on('scroll', debounced_version);
debounced_version.cancel();
================================================================================================================================================================================
CALL, APPLY and BIND method: These methods allow us to write a function once and invoke it in a different context. They all attach this into a function (or object) 
and the difference is in the function invocation. Call and apply are pretty interchangeable. Just decide whether it‚Äôs easier to send in an array or a comma separated 
list of arguments. I always remember which one is which by remembering that Call is for comma (separated list) and Apply is for Array. Bind is a bit different. 
It returns a new function. Call and Apply execute the current function immediately. The main concept behind all this methods is Function burrowing.

CALL:
1. It is predefined javascript method.
2. An object can use a method belonging to another object.
3. Call invokes the function and allows you to pass in arguments one by one.
APPLY:
1. Apply invokes the function and allows you to pass in arguments as an array.
BIND:
1. We can bind an object to a common function, so that the function gives different results when its need.
2. It takes an object as an first argument and creates a new function.

Example1:
const people={
 fullName: function(){
   return this.firstName+" "+this.lastName;
 }
}
const person1={
  firstName: "Priya",
  lastName:"Bagde"
 } 
console.log(people.fullName.call(person1)); //Priya Bagde
console.log(people.fullName.apply(person1)); //Priya Bagde
let bound = people.fullName.bind(person1)
console.log(bound()) //Priya Bagde

Example2:
const obj = {name:"Priya"}
let greeting = function(a,b){
  return a+" "+this.name+" "+b;
}
console.log(greeting.call(obj, "Hello", "How are you?"));
console.log(greeting.apply(obj, ["Hello", "How are you?"]));
let test=greeting.bind(obj);
console.log(test("Hello", "How are you?"))
================================================================================================================================================================================
Hoisting:
1. To move all of the variable and function declarations at the top of the current scope.
2. Hoisting is JavaScript's default behavior of moving declarations to the top.
3. A variable can be used before it has been declared.
4. Note: JavaScript only hoists declarations, not the initializations.
5. JavaScript allocates memory for all variables and functions defined in the program before execution.
6. Due to the concept of hoisting in JavaScript, we can call a function even before we define the function definition in our program's code.
7. Variables defined with let and const are hoisted to the top of the block, but not initialized.Let and const are also hoisted but we cant access them 
until they are assigned because they are in Temporal dead zone.To avoid Temporal deadzone we need to declare let and const to the top of our program!
***when const gets hoisted it will be defined undefined,and further processing will get assigned the value , this violated the meaning of const , this is the fundamental reason why const doesn't get hoisted and let just got tagged along with this feature.

-- Can able to access variable and function before initialise. Can able to access it without any error.
-- console.log(getName); without parenthisis -- print the body of function.
-- if we remove var x=7 then it will get as refrennce error: x is not defined because x is not present at all and we are trying to access it.
-- with arrow and function expression 
-- callstack
-- console.log(greetingName) //print the body  of a function

JavaScript Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, 
before execution of the code.
This is a complete textbook type definition (thanks to MDN Docs for this), but what does it mean in simple words.
Hoisting simply means that we can access variables, before their initialisation & functions, before their declaration.
it gives us an advantage that no matter where functions and variables are declared, they are moved to the top of their scope 
regardless of whether their scope is global or local




Examples:
1. Hoisting Function: If i write below code then JS compiler auto move declaration first then call of a function.
hello() //call
function hello(){ //declaration
  console.log("Hello world")
} 

2. Hoisting Var keyword:
var x; //declaration
console.log(x) //call //output will be undefined because if value is not assigned before call then always assign a "undefined" value. whereas it doesn't provide
undefined for const and let keywords
x=7; //assignment
------------
var x=7; //declaration and assignment
console.log(x) //call //7
------------
x=7; //assignment
console.log(x) //call //7
var x; //declaration
------------
console.log(x) //call //undefined
x=7; //assignment
var x; //declaration
------------
console.log(x) //call //undefined
var x=7; //declaration

3. Let/const Hoising:
let x=7; //declaration and assignment
console.log(x) //call //7
-------------
const x; //declaration 
console.log(x) //call //Missing initializer in const declaration 
x=7; //assignment

-------------------------------------------------------------------------------------
Hoisting:
var x = 1;

function greeting(){
  console.log("Hi greeting");
}

var greeting1 = function (){
  console.log("Hey greeting1");
}

var greeting2 = () =>{
  console.log("Hello greeting2");
}

console.log(x); //1
greeting(); //Hi greeting
greeting1(); //Hey greeting1
greeting2(); //Hello greeting2
-----------------------------------------------------------------------
console.log(x); //undefined //1
greeting(); //function body will assign before executing //Hi greeting- as output post execution
//greeting1(); //Uncaught TypeError: greeting1 is not a function because its treeting like a variable not a function, so rather then storing a function body it's storing undefined by default.
//greeting2(); ////Uncaught TypeError: greeting1 is not a function because its treeting like a variable not a function, so rather then storing a function body it's storing undefined by default.

var x = 1;

function greeting(){
  console.log("Hi greeting");
}

var greeting1 = function (){
  console.log("Hey greeting1");
}

var greeting2 = () =>{
  console.log("Hello greeting2");
}
================================================================================================================================================================================
Window and This:

Window:
1. Javascript engine create global context execution and allocate some memory space. It is a big object with lot of methods and functions which is created in global space 
by JS engine.
2. Window is the main JavaScript object root, aka the global object in a browser, and it can also be treated as the root of the document object model. You can access it as window.
3. window.document or just document is the main object of the potentially visible (or better yet: rendered) document object model/DOM.
4. window is the global object, you can reference any properties of it with just the property name - so you do not have to write down window. - it will be figured out by the runtime.
5. window.document.getElementById("header") is the same as document.getElementById("header").

This:
1. At global level THIS points to the window. 
2. With Window object THIS variable is created by default.
3. This === window //true

Example:
var a=10;
function b(){
 var x=10;
}
console.log(window.a); //10
console.log(a); //10
console.log(this.a); //10
================================================================================================================================================================================
Even Propogation an STOP Propogation: Bydefault event capturing happen first and then even bubbling happen.

Event Bubbling:
1. When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors. With bubbling, the event is 
   first captured and handled by the innermost element and then propagated to outer elements.
2. Bydefault event bubbling execute. To run event bubbling required to mention 3rd argument as FALSE or nothing.
3. "child clicked"
"parent clicked"
"grandparent clicked"
4. Drawback: Bubbling not occur at blur, focus, resizing of window etc.

Event Capturing or Event Trickling:
1. With capturing, the event is first captured by the outermost element and propagated to the inner elements.
2. To run event capturing required to mention 3rd argument as TRUE.
3. "grandparent clicked"
"parent clicked"
"child clicked"

Example:
html-
<div id="grandparent">
  <div id="parent">
    <div id="child">
      </div>
</div>
</div>

css-
div{
  min-width: 10px;
  min-height: 10px;
  border: 1px solid red;
  padding: 30px;
}

js-
for bubbling:
document.querySelector("#grandparent").addEventListener("click",()=> {console.log("grandparent clicked")}, false); or document.querySelector("#grandparent").addEventListener("click",()=> {console.log("grandparent clicked")});
document.querySelector("#parent").addEventListener("click",()=> {console.log("parent clicked")}, false); or document.querySelector("#parent").addEventListener("click",()=> {console.log("parent clicked")});
document.querySelector("#child").addEventListener("click",()=> {console.log("child clicked")}, false); or document.querySelector("#child").addEventListener("click",()=> {console.log("child clicked")})
for capturing:
document.querySelector("#grandparent").addEventListener("click",()=> {console.log("grandparent clicked")}, true);
document.querySelector("#parent").addEventListener("click",()=> {console.log("parent clicked")},true);
document.querySelector("#child").addEventListener("click",()=> {console.log("child clicked")},true); 
stopPropogation:
document.querySelector("#grandparent").addEventListener("click",()=> {console.log("grandparent clicked")}, false);

document.querySelector("#parent").addEventListener("click",(e)=> {console.log("parent clicked"); e.stopPropogation()},false);

document.querySelector("#child").addEventListener("click",()=> {console.log("child clicked")},false); 

================================================================================================================================================================================
Event Delegation:

1. Event delegation makes use of one of the Event Propagation techniques called Event Bubbling
2. if we have a lot of elements handled in a similar way, then instead of assigning a handler to each of them ‚Äì we put a single handler on their common ancestor.
3. In the handler we get event.target to see where the event actually happened and handle it.
4. Less memory usage, better performance.
5. Less time required to set up event handlers on the page.
6. Event delegation is a pattern to handle events efficiently in JavaScript. The main idea is to reduce the number of event handlers on a webpage and thus 
   improving the performance of the website.
7. When there are multiple DOM elements present, instead of adding event handlers on each one of them, you can just add one event handler 
   (on the parent/common ancestor element) which can do the exact same work which all those multiple event handlers were supposed to do.

Example:

html-
Counter: <input type="button" value="1" data-counter>
One more counter: <input type="button" value="2" data-counter>
<script>
  document.addEventListener('click', function(event) {

    if (event.target.dataset.counter != undefined) { 
      event.target.value++;
      console.log(event.target.value)
    }
  });
</script>
================================================================================================================================================================================
Polyfill:

1. With the help of polyfill can write own implementation of BIND function.
2. Polyfills is a way to use modern features (usually JS) on browsers where it is currently unsupported.  We do this by mimicking the functionality using supported methods 
along with our own logic.
3. A polyfill is a piece of code (usually JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it.

Polyfill: Sometimes array push, pop or filter methods and some window's functions like window.localstorage and window.sessionstorage these functions are not supported
by browser, so in this case we can provide our own fallback support or own code that it replace the native functions

Example for bind:
With Bind-
let name ={
  first: "Priya",
  last: "Bagde"
}
let printName = function(){
  console.log(this.first+this.last)
}
let printNameFinal= printName.bind(name)
printNameFinal()

Without Bind-
let name ={ first: "Priya", last: "Bagde"}
let printName = function(town, state){ console.log(this.first+" "+this.last+" "+town+" "+state)}
Function.prototype.mybind= function(...args){ //printName arguments
  let obj = this; //printName
  params = args.slice(1)
  return function(...args2){ //printNameFinal arguments
   obj.apply(args[0], [...params, ...args2])
  }
}
let printNameFinal= printName.mybind(name, "chhindwara")
printNameFinal("MadyaPradesh")
================================================================================================================================================================================
Promises:-

üëâWhy do you need a promise?
‚úåüèºPromises are used to handle asynchronous operations. They provide an alternative approach for callbacks by reducing the callback hell and writing the cleaner code.

üëâWhat are the three states of promise ?
‚úåüèºPromises have three states:
Pending: This is an initial state of the Promise before an operation begins
Fulfilled: This state indicates that the specified operation was completed.
Rejected: This state indicates that the operation did not complete. In this case an error value will be thrown.

üëâWhat is promise chaining ?
‚úåüèºThe process of executing a sequence of asynchronous tasks one after another using promises is known as Promise chaining.

üëâWhat is promise.all ?
‚úåüèºPromise.all is a promise that takes an array of promises as an input (an iterable), and it gets resolved when all the promises get resolved or any one of them gets rejected. For example, the syntax of promise.all method is below,
Promise.all([Promise1, Promise2, Promise3])
.then(result) => { console.log(result) })
.catch(error => console.log(`Error in promises ${error}`))

üëâWhat are the pros and cons of promises over callbacks ?
‚úåüèºPros:
It avoids callback hell which is unreadable
Easy to write sequential asynchronous code with .then()
Easy to write parallel asynchronous code with Promise.all()
Solves some of the common problems of callbacks(call the callback too late, too early, many times and swallow errors/exceptions)
Cons:
It makes little complex code
You need to load a polyfill if ES6 is not supported

üëâHow to cancel a fetch request ?
‚úåüèºOne shortcoming of native promises is no direct way to cancel a fetch request. But the new AbortController from js specification allows you to use a signal to abort one or multiple fetch calls. 
================================================================================================================================================================================
üëâWhat are default parameters?
‚úåüèºIn E5, we need to depend on logical OR operators to handle default values of function parameters. Whereas in ES6, Default function parameters feature allows parameters to be initialized with default values if no value or undefined is passed. Let's compare the behavior with an examples,
//ES5
var calculateArea = function(height, width) {
   height =  height || 50;
   width = width || 60;
   return width * height;
}
console.log(calculateArea()); //300
//ES6
var calculateArea = function(height = 50, width = 60) {
   return width * height;
}
console.log(calculateArea()); //300

‚úåüèºAfter default parameters you should not have parameters without default value-
function printValue(a=1, b) {
    console.log("a = " + a + " and b = " + b);
}
printValue();    // Logs: a = 1 and b = undefined
printValue(7);    // Logs: a = 7 and b = undefined
printValue(7, 3);    // Logs: a = 7 and b = 3

‚úåüèºDefault values for parameters and calling it without arguments-
function add(a=10, b=20)
{
	return a+b;
}
console.log(" Sum is : " + add());   // No argument //30
console.log(" Sum is : " + add(1));   // with one argument //21
console.log(" Sum is : " + add(5,6));   // with both argument  //11

‚úåüèºJavaScript Default Parameters with null or empty Argument-
function test(a = 1)
{
    console.log(typeof a);
    console.log("Value of a: " + a);
}
test();    // number, Value of a: 1
test(undefined);    // number, Value of a: 1
test('');    // string, Value of a: 
test(null);    // object, Value of a: null

‚úåüèºDefault Parameters are evaluated at Call time-
function append(value, array = []) {
    array.push(value)
    return array
}
append(1)  // [1]
append(2)  // [2], not [1, 2]
================================================================================================================================================================================
JWT Token:
1. JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.
2. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a public/private key pair using RSA.
================================================================================================================================================================================
Polyfill of Bind:
const name ={
  firstName: "Priya", 
  lastName: "Bagde"
}

let printName = function(hometown, state, country){
  console.log(this.firstName + " " + this.lastName + " " + state + " " + country)
}
let printMyName = printName.bind(name, "Mumbai", "MH"); 
printMyName("India"); //with bind method

//polyfill
Function.prototype.mybind = function(...args){
  let obj = this,
      params = args.slice(1);
  return function (...args2){
    obj.apply(args[0], [...params, ...args2])
  }
}
let printMyName2 = printName.mybind(name, "Mumbai", "MH")
printMyName2("India"); //with polyfill of bind 
================================================================================================================================================================================
Polyfill of Call:
const myName = {
  firstName: "Priya",
  lastName : "Bagde"  
}

function printName(city, country){
    console.log( `${this.firstName} ${this.lastName}, ${city}, ${country}` );
}

Function.prototype.myCall= function(context, ...args){
  let currentContext = context || globalThis;
  let randomProp = Math.random();
  while(currentContext.randomProp !== undefined){
    randomProp = Math.random();
  }
  currentContext.randomProp = this;
  let result = currentContext.randomProp(...args);
  delete currentContext.randomProp;
  return result;
}

printName.myCall(myName, "MH", "India")
================================================================================================================================================================================
Polyfill of Apply:
const myName = {
  firstName: "Priya",
  lastName : "Bagde"  
}

function printName(city, country){
    console.log( `${this.firstName} ${this.lastName}, ${city}, ${country}` );
}

Function.prototype.myCall= function(context, args){
  let currentContext = context || globalThis;
  let randomProp = Math.random();
  while(currentContext.randomProp !== undefined){
    randomProp = Math.random();
  }
  currentContext.randomProp = this;
  let result = currentContext.randomProp(...args);
  delete currentContext.randomProp;
  return result;
}

printName.myCall(myName, ["MH", "India"])
================================================================================================================================================================================
Polyfill od forEach:
Array.prototype.ourForEach = function (callBack) {
  for (let i = 0; i < this.length; i++) {
    callBack(this[i]);
  }
};
const names = ["ali", "hamza", "jack"];
names.ourForEach((x)=> console.log(x))
================================================================================================================================================================================
Polyfill of Map:
// Doing this will allow us to use arr.myMap() syntax
Array.prototype.myMap =function(cb) {
  // rseults results array that gets returned at the end
  const results = [];
  for (let i = 0; i < this.length; i++) {
    // returned values of our cb are pushed in the reults[]
    // 'this' referes to the passed array
    results.push(cb(this[i], i, this));
  }

  return results;
}

const arr = [1, 2, 3, 4, 5, 6];
const myMapResult = arr.myMap((el, _idx, _arr) => {
  return el * 2;
});

console.log(myMapResult); //[2, 4, 6, 8, 10, 12];
================================================================================================================================================================================
Polyfill of Filter:
// Doing this will allow us to use arr.myFilter() syntax
Array.prototype.myFilter = function myFilter(cb) {
  const results = [];
  for (let i = 0; i < this.length; i++) {
     if (cb(this[i])) {
      results.push(this[i]);
    }   
  }
  return results;
}

const arr = [1, 2, 3, 4, 5, 6];
const foo = [
  { name: "S", age: 2 },
  { name: "V", age: 3 },
];

const myFilterResult = foo.myFilter((el, _idx, _arr) => {
  return el.name !== "S";
});
console.log(myFilterResult); // [{ name: "V", age: 3 }]
======================================================================================================================================================================
Polyfill of Reduce:
// Doing this will allow us to use arr.myReduce() syntax
Array.prototype.myReduce =function (cb, initialValue) {
  let acc;let curr;
  if (!this.length && !initialValue)
    throw new Error("Can't reduce on empty array, provide initial value");
  else {
    //  If initialValue is given then acc is that or acc = is the 0th index of this
    acc = initialValue ? initialValue : this[0];
    for (let i = 1; i < this.length; i++) {
      // current value of the array
      curr = this[i];
      // the retuned cb value is assigned to acc
      acc = cb(acc, curr, i, this);
    }
  }
  return acc;
}
const arr = [1, 2, 3, 4];
const myReduceResult = arr.myReduce((acc, curr, _idx, _arr) => {
  acc += curr;
  return acc;
});
console.log(myReduceResult); // 10
==========================================================================================================================================================================
Polyfill of promise.all:
//let myPromiseAll
Promise.all = (promises) => {
  let responses = [];
  let errorResp = [];
  return new Promise((resolve, reject) => {
    /** Loop over promises array **/
    promises.forEach(async (singlePromise, i) => {
      try {
        /** wait for resolving 1 promise **/
        let res = await singlePromise;
        responses.push(res);
        if (i == promises.length - 1) {
          if (errorResp.length > 0) {
            reject(errorResp);
          } else {
            // resolve(esponses)
            // To know our cutom promise function returning result
            resolve("custom promise ::" + responses);
          }
        }
      } catch (err) {
        errorResp.push(err);
        reject(err);
      }
    });
  });
};

let p1 = Promise.resolve("Promise1 resolved");

let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Promise 2 resolved after 2 seconds");
  }, 1000);
});

Promise.all([p1, p2]).then(
  (res) => {
    console.log("Response => ", res);
    document.write("<b>Response => </b>" + res);
  },
  (err) => {
    console.log("error =>", err);
  }
);
========================================================================================================================================================================
Polyfill of //let myPromiseAll
Promise.all = (promises) => {
  let responses = [];
  let errorResp = [];
  return new Promise((resolve, reject) => {
    /** Loop over promises array **/
    promises.forEach(async (singlePromise, i) => {
      try {
        /** wait for resolving 1 promise **/
        let res = await singlePromise;
        responses.push(res);
        if (i == promises.length - 1) {
          if (errorResp.length > 0) {
            reject(errorResp);
          } else {
            // resolve(esponses)
            // To know our cutom promise function returning result
            resolve("custom promise ::" + responses);
          }
        }
      } catch (err) {
        errorResp.push(err);
        reject(err);
      }
    });
  });
};

let p1 = Promise.resolve("Promise1 resolved");
let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Promise 2 resolved after 2 seconds");
  }, 1000);
});
let p3 = Promise.reject("Promise Rejected")
Promise.all([p1, p2, p3]).then(
  (res) => {
    console.log("Response => ", res);
    document.write("<b>Response => </b>" + res);
  },
  (err) => {
    console.log("error =>", err);
  }
);
======================================================================================================================================================================
Polyfill of all.settled:-
Promise.allSettled = function(promises) {
  let mappedPromises = promises.map((p) => {
    return p
      .then((value) => {
        return {
          status: 'fulfilled',
          value
        };
      })
      .catch((reason) => {
        return {
          status: 'rejected',
          reason
        };
      });
  });
  return Promise.all(mappedPromises);
};

let promises = [
  Promise.resolve(2),
  Promise.reject('This is rejected'),
  new Promise((resolve, reject) => setTimeout(resolve, 400, 67)),
];

Promise.allSettled(promises).then((result) => console.log(result)); 
/*[{
  status: "fulfilled",
  value: 2
}, {
  reason: "This is rejected",
  status: "rejected"
}, {
  status: "fulfilled",
  value: 67
}]*/
===========================================================================================================================================================================
Polyfill of promises.allsettled:
Promise.allSettled = function (arrayOfPromises = []) {
  return new Promise(function promiseIterator(resolve, reject) {
    let result = [];
    arrayOfPromises.forEach((item) => {
      item
        .then((value) => {
          result.push({ status: "fulfilled", value: value });
          if (arrayOfPromises.length === result.length) resolve(result);
        })
        .catch((err) => {
          result.push({ status: "rejected", reason: `${err}` });
          if (arrayOfPromises.length === result.length) resolve(result);
        });
    });
  });
};

let promises = [
  Promise.resolve(2),
  Promise.reject('This is rejected'),
  new Promise((resolve, reject) => setTimeout(resolve, 400, 67)),
];

Promise.allSettled(promises).then((result) => console.log(result));
=======================================================================================================================================================================
Polyfill of race:
Promise.letsBuildARace = function(arrayOfPromises){
return new Promise((resolve, reject) => {
arrayOfPromises.forEach((promise) => {
Promise.resolve(promise).then(resolve, reject);
})
})
}
For Example:
var a = new Promise((resolve) => setTimeout(()=>{resolve(3)},200));
var b = new Promise((resolve,reject)=>reject(9));
var c= new Promise((resolve) => resolve(5));

var d= Promise.letsBuildARace([a,b,c]);
d.then(result=>console.log(result))
=========================================================================================================================================================================
Polyfill of Any:
Promise.letsBuildAnAny = function(arrayOfPromises){
let errors = [];
return new Promise((resolve, reject) => {
arrayOfPromises.forEach((promise, index)=>{
Promise.resolve(promise)
.then(resolve)
.catch((error)=>{
errors.push(error);
if(errors.length == arrayOfPromises.length)
reject(errors);
})
})
})
}
For Example:
var a = new Promise((resolve) => setTimeout(()=>{resolve(3)},200));
var b = new Promise((resolve,reject)=>reject(9));
var c= new Promise((resolve) => resolve(5));

var d= Promise.letsBuildAnAny([a,b,c]);
d.then(result=>console.log(result))
===========================================================================================================================================================================
Rest Parameter in Array : 
function addSum(a,b,c, ...rest){ // ...rest indicating combination of those arguments which are left(rest).
  console.log(...rest) //6,7
  console.log(rest) //[6,7]
  console.log(arguments) //ES5 //{"0":2, "1":3, "2":4, "3":6, "4":7}
  return a+b+c+rest[0]+rest[1];
}
console.log(addSum(2,3,4,6,7)) //22
======================================================================================================================================================================
//Spread Operator  in Array:
function getNames(name1, name2, name3){
  console.log(name1,name2, name3);
}
var names =["priya", "riya", "supriya"]
getNames(names[0], names[1], names[2]); //"priya" "riya" "supriya"
getNames(...names) //spread operator here used to spread the individual arguments //best approach because here we are passing all the arguments but we can use some of the arguments inside function without an error. Other approaches will gives an error to pass those arguments which are used in function.
getNames(names)
=========================================================================================================================================================================
Rest Spread in object: 
var student ={
  name: "priya",
  age : 100,
  hobbies : ["cooking", "dancing"]
}

//const age = student.age; //earlier we like this
//console.log(age) //10

//const {age, ...rest} = student; //using destructuring
//console.log(age, rest) //100 {"name": "priya", "hobbies":["cooking", "dancing"]}

const {...rest} = student;
console.log(rest) //{"name": "priya", "age": 100, "hobbies":["cooking", "dancing"]}
=====================================================================================================================================================================
//spread operator in object: (Change the value of age)
var student ={
  name: "priya",
  age : 100,
  hobbies : ["cooking", "dancing"]
}

var newStudent ={
  ...student, //coping one object to another object
  age : 101
}
console.log(newStudent)
====================================================================================================================================================================
Callback, Promise and Async/await :-
const data = [ //array of object
  {name: "priya", role: "software developer"},
  {name: "riya", role: "software developer"},
  {name: "supriya", role: "software developer"}
];

function getData(){
   setTimeout(()=>{
   let output ="";
   data.forEach((item)=>{
    output +=`<li> ${item.name}</li>`
   })    
   document.body.innerHTML = output;
 }, 1000)  //use 5000 instead of 1000 then we get a name of "dhanupriya".
}
function createData(dataInput){
setTimeout(()=>{data.push(dataInput)}, 2000) 
}
createData({name: "dhanupriya", role: "software developer"})
getData()
=====================================================================
Callback:
const data = [ //array of object
  {name: "priya", role: "software developer"},
  {name: "riya", role: "software developer"},
  {name: "supriya", role: "software developer"}
];

function getData(){
   setTimeout(()=>{
   let output ="";
   data.forEach((item)=>{
    output +=`<li> ${item.name}</li>`
   })    
   document.body.innerHTML = output;
 }, 1000)  
}
function createData(dataInput, callback){
   setTimeout(()=>{
        data.push(dataInput) 
        callback(); //getdata function will get call once we push the new dataInput
   },2000) 
}
createData({name: "dhanupriya", role: "software developer"}, getData) //we are passing getData function as a callback
====================================================================
Promises:
const data = [ //array of object
  {name: "priya", role: "software developer"},
  {name: "riya", role: "software developer"},
  {name: "supriya", role: "software developer"}
];

function getData(){
   setTimeout(()=>{
   let output ="";
   data.forEach((item)=>{
    output +=`<li> ${item.name}</li>`
   })    
   document.body.innerHTML = output;
 }, 1000)  //use 5000 instead of 1000 then we get a name of "dhanupriya".
}
function createData(dataInput){
return new Promise((resolve, reject)=>{
  setTimeout(()=>{
        data.push(dataInput);
        let error = false; //if trure then went to catch block
        if(!error) resolve();
        else reject("Error!!!!");
   },2000) 
})
   
}
createData({name: "dhanupriya", role: "software developer"})
.then(getData)
.catch(err => console.log("Errors !"))
====================================================================
Async/Await:
const data = [ //array of object
  {name: "priya", role: "software developer"},
  {name: "riya", role: "software developer"},
  {name: "supriya", role: "software developer"}
];

function getData(){
   setTimeout(()=>{
   let output ="";
   data.forEach((item)=>{
    output +=`<li> ${item.name}</li>`
   })    
   document.body.innerHTML = output;
 }, 1000)  //use 5000 instead of 1000 then we get a name of "dhanupriya".
}
function createData(dataInput){
return new Promise((resolve, reject)=>{
  setTimeout(()=>{
        data.push(dataInput);
        let error = false; //if trure then went to catch block
        if(!error) resolve();
        else reject("Error!!!!");
   },2000) 
})   
}

async function start(){ //using sync and await
await createData({name: "dhanupriya", role: "software developer"});
getData();
}
start();
======================================================================================================================================================================
Callback:
var sum = function(a,b,c){
  return{
    sumOfTwo: function(){return a+b},
    sumOfThree:function(){return a+b+c}
  }
}

var store = sum(2,3,4);
console.log(store)
console.log(store.sumOfTwo())
console.log(store.sumOfThree())
--------------------------------------------------
var sum = function(a){
     var c=4;
     return function(b){
       return a+b+c;
     }
}
var store = sum(2);
console.log(store)
console.log(store(5))
=========================================================================
Call, apply and bind:
var userDetails ={
  name: "Priya",
  age: 100,
  role: "Software Developer",
  printDetail : function(){
    console.log(this)// this representing userDetails whole object 
  }
}
userDetails.printDetail();

var userDetails2 ={
  name: "Riya",
  age: 101,
  role: "Software Developer"
}

userDetails.printDetail.call(userDetails2); //if i want line 6th "this" should point to userDetails2 then use call function.
-----------------------------------------------------------------------------------
var userDetails ={
  name: "Priya",
  age: 100,
  role: "Software Developer"
}
let printDetail =  function(){
    console.log(this.name)
}
printDetail.call(userDetails); // if function is independented of object.

var userDetails2 ={
  name: "Riya",
  age: 101,
  role: "Software Developer"
}
printDetail.call(userDetails2); 
--------------------------------------------------------------------------------
var userDetails ={
  name: "Priya",
  age: 100,
  role: "Software Developer"
}
let printDetail =  function(country){
    console.log(this.name+" "+country)
}
printDetail.call(userDetails, "India"); // if function is independented of object.

var userDetails2 ={
  name: "Riya",
  age: 101,
  role: "Software Developer"
}

printDetail.call(userDetails2, "India"); 
printDetail.apply(userDetails2, ["India"]); 
let bindfunc= printDetail.bind(userDetails2, "India"); //creating a copy and invoke whenever require //don't call the diectly here like call function
bindfunc();
========================================================================================================================================================================
Foreach:
const Data=[
{name:"Google", category:"Product Based"},
{name:"Accenture", category:"service Based"},
{name:"Amazon", category:"Product Based"}
];

for(let i=0; i<Data.length; i++){
  console.log(Data[i])
}

//foreach is HOF which take callback 
Data.forEach((item)=>{ console.log(item) })
=====================================================================================================================================================================
Filter:
const Age=[1,2,3,4,5,6,7,8,9,0]
for(var i=0;i<Age.length;i++){
  if(Age[i]>5){
    console.log(Age[i])
  }
}

const UpdatedAge= Age.filter(function(item){
  if(item>5){
    return true;
  }
})
console.log(UpdatedAge)

const UpdatedAge= Age.filter((item)=>(item>5))
console.log(UpdatedAge)
=====================================================================================================================================================================
sort:-
const Data =[11,44,2,66,3,7,22,3]
const sorted= Data.sort((a,b)=>{
  if(a>b) return 1;
  else return -1;
})
console.log(sorted) //prefer for object
//a<b //[66,44,22,11,7,3,3,2]
//a>b //[2,3,3,7,11,22,44,66]


const sorted1= Data.sort((a,b)=>b-a)
console.log(sorted1) //prefer for arrays
//b-a //[66,44,22,11,7,3,3,2]
//a-b //[2,3,3,7,11,22,44,66]
======================================================================================================================================================================
Reduce:
const Data =[11,44,2,66,3,7,22,3]
var updatedData=0;
for(var i=0; i<Data.length; i++){
  updatedData=updatedData+Data[i]
}
console.log(updatedData)
----------------
const updated= Data.reduce((acc, item)=>{
  return acc+item
},0)

console.log(updated)
======================================================================================================================================================================
ProtoType: If we can inherit the property of the one class to other class called as Inheritence. 

const objName = {
 name : "priya",
 getName : function(){
   return this.name; //wanted to access above name inside block so we used "this"
 }
}
console.log("1",objName.getName()); 

const objState = {
  //name: "riya",
  state : "pune",
  __proto__ : objName
}
console.log("2",objState.getName()); //if will find in current object, if not available then it move to upper object continuously. If still not found then it will give undefined.

const objCountry = {
  name: "supriya",
  country : "india",
  __proto__ : objState
}
console.log("3", objCountry.getName() ,objCountry.state)
-----------------------------------------------------------------

Array.prototype.convertToObject = function(){
  let newObj ={}
  this.forEach( ele =>{
            newObj[ele]= ele;
        }      
  )
  return newObj;
}
const arr =["priya"];
console.log(arr.convertToObject()); //array to object conversion with prototype
------------------------------------------------------------------
function myProtoType(name){
 return this.name=name;
}
myProtoType.prototype=objName;
const myproto = myProtoType("priya")
console.log(myproto);
console.log(myproto.getName());
==========================================================================================================================================================================
Set: It contains only unique values. Can iterate.
let arr =[1,2,3]
let obj = new Set(arr) //set takesarray, string, object etc
obj.add(4)
obj.delete(3)
console.log(obj)

var obj1={name:"priya"}
obj.add(obj1)
console.log(obj)
======================================================================================================================================================================
Map: store in key value pair. Can iterate.
let myMap = new Map([["a1", "priya"],["a2","riya"]])
myMap.set("a2","supriya")
console.log(myMap.get("a2"))// will get last value which we will assign
for(let [key,value] of myMap){
  console.log(`keys ${key}, value ${value}`)
}
=======================================================================================================================================================================
WeakSet: only store object, can't iterate with for/foreach
let ws = new WeakSet()
const obj={"name":"priya"}
ws.add(obj)
console.log(ws.has(obj));
WeakMap: It's similar to WeakSet where can't able to iterate and only stores an object
======================================================================================================================================================================
Hoisting : Its related to memory management.
Global execution context having 2 component. In memory componenet variable and functions will store. Variable store with undefined and function store with prototype
of function. Var or functions will push to Callstack and then pop.
============================================================================================================================================================================
2 ways of Currying function with closures:
  
  
*****Using Normal Function******
  
function add(a){
  return function(b){
    if(b) return add(a+b);
    return a;
  }
}
console.log('Sum :', add(1)(2)(3)(4)(5)(6)(7)(8)()) //"Sum :", 36


*****Using Arrow Function******
  
function sum(num1) {
        return (num2) => {
            if(!num2) {
                return num1;
            }
            return sum(num1 + num2);
        }
    }
console.log('Sum :', sum(1)(2)(3)(4)(5)(6)(7)(8)()) //"Sum :", 36

*****Using Arrow ShortHand Function******
const sum = (a) => (b) => (c) => (d) => a+b+c+d
console.log('Sum :', sum(1)(2)(3)(4))

*****Using Partial Function******
function sum(...a){
  return function(...b){
    if(b?.length){
      return sum([...a,...b].reduce((acc, curr)=>acc+curr,0))
    }
    return a;
  }
}
console.log('Sum :', sum(1,2,3)(4,5)(6,7,8,9)()) //"Sum :", 36
=====================================================================================================================================================================
How to Remove All Falsy Values from an Array in JavaScript:
*************Using Filter Auto Coercion*************

[1, 2, 'b', 0, {}, '', NaN, 3, undefined, null, 5].filter(a => a);

*************Using !!*************

[1, 2, 'b', 0, {}, '', NaN, 3, undefined, null, 5].filter(a => !!a);

*************Using Boolean*************

[1, 2, 'b', 0, {}, '', NaN, 3, undefined, null, 5].filter(a => Boolean(a));
 
*************Using Boolean directly*************
  
[1, 2, 'b', 0, {}, '', NaN, 3, undefined, null, 5].filter(Boolean); 

//This works because Boolean itself is a function, and the arguments filter supplies are passed directly to it.
//Boolean() is also a function that returns truthy when true and falsy when false!
========================================================================================================================================================================
Memo Function:

********************Memoizing functions**********************
  
const add = (n) => (n + 10);
add(9);
// a simple memoized function to add something
const memoizedAdd = () => {
  let cache = {};
	return (n) => {
		if (n in cache) {
			console.log('Fetching from cache');
			return cache[n];
		}
		else {
			console.log('Calculating result');
			let result = n + 10;
			cache[n] = result;
			return result;
		}
	}
}
// returned function from memoizedAdd
const newAdd = memoizedAdd(); 
console.time(); console.log(newAdd(9)); console.timeEnd();// calculated
console.time(); console.log(newAdd(9)); console.timeEnd();	// cached
console.time(); console.log(newAdd(9)); console.timeEnd();	// cached
//output:
//Calculating result    19    default: 0.38427734375 ms
//Fetching from cache   19    default: 0.30810546875 ms
//Fetching from cache   19    default: 0.27612304687 ms

********************Memoizing recursive functions**********************
  
// a simple pure function to get a value adding 10
const add = (n) => (n + 10);
// a simple memoize function that takes in a function and returns a memoized function
const memoize = (fn) => {
  let cache = {};
  return (...args) => {
    let n = args[0];  // just taking one argument here
    if (n in cache) {
      console.log('Fetching from cache');
      return cache[n];
    }
    else {
      console.log('Calculating result');
      let result = fn(n);
      cache[n] = result;
      return result;
    }
  }
}
// creating a memoized function for the 'add' pure function
const memoizedAdd = memoize(add);
console.time(); console.log(memoizedAdd(3)); console.timeEnd();// calculated
console.time(); console.log(memoizedAdd(3)); console.timeEnd();	// cached
console.time(); console.log(memoizedAdd(3)); console.timeEnd();	// cached
//output:
//Calculating result     13      default: 0.45068359375 ms
//Fetching from cache    13      default: 0.16674804687 ms
//Fetching from cache    13      default: 0.161865234375 ms
========================================================================================================================================================================
*********************Using Custom function with Recursion*****************
const age=[1,2,
           [12,23,[75,34,[2,34]],[32,45]],
           [3,456],
           [56,[5]]]
var result=[]
function flattenArray(inputArray)
{
  inputArray.map((value)=>{
    if(Array.isArray(value))
    { 
      flattenArray(value)
    }
    else{
      result.push(value)
    }})
  }
flattenArray(age)
console.log(result) ////[1,2,12,23,75,34,2,34,32,45,3,456,56,5]

*********************Using One Line Arrow function*****************
var result=[]
const flattenArray = (inputArray) => {
  inputArray.map((value)=> Array.isArray(value) ?  flattenArray(value) :  result.push(value))
}
flattenArray(age)
console.log(result) //[1,2,12,23,75,34,2,34,32,45,3,456,56,5]

*********************Using Flat*****************
const age=[1,2,
           [12,23,[75,34,[2,34]],[32,45]],
           [3,456],
           [56,[5]]]
var updatedArr= age.flat(Infinity);
console.log(updatedArr) //[1,2,12,23,75,34,2,34,32,45,3,456,56,5]
  
*********************Using Reducer****************
function flatDeep(arr, d = 1) {
   return d > 0 ? arr.reduce((acc, val) => 
                             acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), [])
                : arr.slice();
};
console.log(flatDeep(arr, Infinity)) //[1,2,12,23,75,34,2,34,32,45,3,456,56,5]
=======================================================================================================================================================================
Regular Expression(Regex):
A regular expression is a group of characters or symbols which is used to find a specific pattern in a text.

Regular expressions are normally case-sensitive so the regular expression The would not match the string the
=======================================================================================================================================================================
Multiple functions:
var arr = [];
const checkSort =(a)=>{
  if(!arr.includes(a) && Number.isInteger(a)){
    arr.push(a)
  }
  return console.log(arr.sort((a,b)=>a-b));
}
checkSort(5);
checkSort(4);
checkSort(2);
checkSort("abc");
checkSort("44");
checkSort(-44);

//output: [-44,2,4,5]
==================================================================================================================================================================
[..."priya"]
// ['p', 'r', 'i', 'y', 'a']
"priya".split('')
// ['p', 'r', 'i', 'y', 'a']
===================================================================================================================================================================
Deep Copy and Shallow Copy:
A deep copy means that "all of the values of the new variable" are copied and disconnected from the original variable. It makes a copy of all the members of X, allocates different memory location for Y and then assigns the copied members to Y to achieve deep copy. In this way, if X vanishes Y is still valid in the memory.
A shallow copy means that certain (sub-)values are still connected to the original variable. It is primarily utilized for copying One Dimensional array elements, where it only copies the elements present at the first level.

A deep copying means that value of the new variable is disconnected from the original variable 
while a shallow copy means that some values are still connected to the original variable.

addresses of X and Y will be the same i.e. they will be pointing to the same memory location.

To copy an object in JavaScript, you have three options. Both spread (...) and Object.assign() perform a shallow copy while the JSON methods carry a deep copy.
--->Assignment operator ‚Äú=‚Äù
--->Use the spread (...) syntax
--->Use the Object.assign() method
--->Use the JSON.stringify() and JSON.parse() methods --where the stringify() method converts a particular JavaScript object to a string, and then the parse() method performs the parsing operation and returns an object.

For a primitive value, you just simply use a simple assignment:The important takeaway here is that you can quickly copy a primitive data type‚Äôs exact value 
in a separate memory space by creating and assigning another variable to the variable being copied. Take note of how it is instantiated ‚Äî const will not 
allow later changes.

let counter = 1;
let copiedCounter = counter;
copiedCounter = 2; //And when you change the value of the copied variable, the value of the original remains the same.
console.log(counter); 
Output: 1


However, if you use the assignment operator for a reference value, it will not copy the value. Instead, both variables will reference the same object in the memory:

 JS objects (as non-primitive data types) differ because they have reference values and those values are mutable. This means they share a memory address when shallow copied.
=========================================================================================================================================================================
function countOccurance(arr){
  let map ={}, sortedArr = arr.sort((a,b)=>a-b);
  for(var item of sortedArr){
    if(map[item]){
        map[item]++
    }else{
        map[item] = 1; 
    }
  }
  return map;
}
console.log(countOccurance([1, 4, 91, 21, 91, 0, 32, 4, 11, 3, 54, 34, 21]))
--------------------------------------------------------------------------------
function countOccurance(arr){
 let map ={}, sortedArr = arr.sort((a,b)=>a-b);
  for(var item of sortedArr){
    if(!(item in map)){ map[item] = 0}
    map[item]++;
  }
  return map;
}
console.log(countOccurance([1, 4, 91, 21, 91, 0, 32, 4, 11, 3, 54, 34, 21]))
-------------------------------------------------------------------
function countOccurance(arr){
 let map ={}, sortedArr = arr.sort((a,b)=>a-b);
  for(var item of sortedArr){
    if(map[item] ==null){ map[item] = 0}
    map[item]++;
  }
  return map;
}
console.log(countOccurance([1, 4, 91, 21, 91, 0, 32, 4, 11, 3, 54, 34, 21]))
-------------------------------------------------------------------
function countOccurance(arr){
 let map ={}, sortedArr = arr.sort((a,b)=>a-b);
  for(var item of sortedArr){
  if(map.hasOwnProperty(item)){
    map[item] = map[item] + 1
  }else{
    map[item] = 1; 
  }
  }
  return map;
}
console.log(countOccurance([1, 4, 91, 21, 91, 0, 32, 4, 11, 3, 54, 34, 21]))
-------------------------------------------------------------------
function countOccurance(arr){
  let map ={}, sortedArr = arr.sort((a,b)=>a-b); 
  for(var item of sortedArr){
   map[item] = map[item]+1 || 1
  }
  return map
}
console.log(countOccurance([1, 4, 91, 21, 91, 0, 32, 4, 11, 3, 54, 34, 21]))
-------------------------------------------------------------------
function countOccurance(arr){
  let map ={}, sortedArr = arr.sort((a,b)=>a-b); //[0,1,3,4,4,11,21,21,32,34,54,91,91]
  for(var item of sortedArr){
   map[item] = (map[item] || 0) + 1
  }
  return map
}
console.log(countOccurance([1, 4, 91, 21, 91, 0, 32, 4, 11, 3, 54, 34, 21]))
-------------------------------------------------------------------
function countOccurance(arr){
  let map ={}, sortedArr = arr.sort((a,b)=>a-b);
  for(var item of sortedArr){
  if(map[item]){
 map[item] = map[item] + 1
  }else{
  map[item] = 1; 
  }
  }
  return map;
}
console.log(countOccurance([1, 4, 91, 21, 91, 0, 32, 4, 11, 3, 54, 34, 21]))
-------------------------------------------------------------------
function countOccurance(arr){
  let map ={}, sortedArr = arr.sort((a,b)=>a-b); 
  for (var i=0; i<sortedArr.length; i++) 
   {
   map[sortedArr[i]] = map[sortedArr[i]] ? map[sortedArr[i]]+1 : 1; 
   }
  return map
}
console.log(countOccurance([1, 4, 91, 21, 91, 0, 32, 4, 11, 3, 54, 34, 21]))
-------------------------------------------------------------------
var frequencySort = function(nums) {
  const hash={}
    for(let item of nums){
      hash[item] 
          ?hash[item]++
          :hash[item]=1
    }
 return hash    
};
console.log(frequencySort([1,1,2,2,2,3]))
--------------------------------------------------------------
var frequencySort = function(nums) {
    let map = new Map();
    for (const i of nums) {
        if (map.has(i)) {
            map.set(i, map.get(i) + 1);
        } else {
            map.set(i, 1);
        }
    }
    console.log(map);
    return map;

};
console.log(frequencySort([1,1,2,2,2,3]))
==========================================================================================================================================================================
Anagram:O(N) 
let NO_OF_CHARS = 256;
function areAnagram(str1, str2)
{
	// Create a count array and initialize all values as 0
	let count = new Array(NO_OF_CHARS).fill(0);
	let i;

  if (str1.length != str2.length) return false;
	for(i = 0; i < str1.length; i++)
	{
		  count[str1[i].charCodeAt(0)]++;
      count[str2[i].charCodeAt(0)]--;
	}

	// See if there is any non-zero value in count array
	for(i = 0; i < NO_OF_CHARS; i++)
	if (count[i] != 0)
	{
		return false;
	}
	return true;
}

// Driver code
let str1 =
"priya".split("");
let str2 =
"riyap".split("");

// Function call
if (areAnagram(str1, str2))
	document.write(
	"The two strings are " +
	"anagram of each other");
else
	document.write(
	"The two strings are " +
	"not anagram of each other");

========================================================================================================================================================================
// How can you make a linkedlist nodes in javascript and 
// hpw to check linkedlist is cyclic or not.

class LinkedList {
  constructor(data){
    this.data = data;
    this.next = null;
  }
}

let head = new LinkedList(10);
let A = new LinkedList(20);
let B = new LinkedList(30);
let C = new LinkedList(40);
let D = new LinkedList(50);

head.next = A;
A.next = B;
B.next = C;
C.next = D;
D.next = A; //it will be circluar linked list
//D.next = null; //it will be single linked list

//output : 10 -> 20 -> 30 -> 40 -> Null

function floyedCycleDetection(){
  let fast = head, slow = head;
  while(fast && fast.next){
    slow = slow.next;
    fast = fast.next.next;
    if(slow == fast) return true;
  }
  return false
}
=======================================================================================================================================================================
This: This is a keyword from where it gets belongs to. This is a current object. In javascript, this behave in diff manner, it depends in the env where it's getting
invoked. (https://www.youtube.com/watch?v=wp-NEcAck1k&t=427s)

In IIFE : this is pointing to Window 
In object : if normal function then pointing to block scope. if arrow function pointing to window.
In function constructor : pointing to function 
If we didn't invoked properly(without paranthesis) then it will give undefined.
=======================================================================================================================================================================
function curryingWithRecursion(a){
  return function(b) {
    return  b ? curryingWithRecursion(a+b) : a
  }
}
console.log(curryingWithRecursion(1)(2)(3)(4)(5)()) //always use at last empty parenthesis
======================================================================================================================================================================
How can you optimise the multiple of times API calls - using debaouncing, we can restrict the function calls ..
Check code implementation:
function debounce(func, a){
  let timer;
  return ()=>{
    clearTimeout(timer);
    timer = setTimeout(()=>{
      func();
    }, a)
  }
}
const printName = () => {
  console.log("Priya"); 
}

debounce(printName(), 8000)()
======================================================================================================================================================================

function maxSumSubArray(arr){
  let max = 0;
  for(let i=0; i<arr.length; i++){
    let currMax = 0;
    for(let j=i; j<arr.length; j++){
        currMax += arr[j]
        if(currMax > max){ //or max = Math.max(max, currMax)
          max = currMax
        }
    }
  }
  return max
}

console.log(maxSumSubArray([1,2,-1,3,-2]))
======================================================================================================================================================================
function hello(){
  for(var i=0; i<=3; i++){
    setTimeout(()=>{
      console.log(i)
    }, 1000)
  }
}
hello() //4 4 4 4

function hello(){
  for(let i=0; i<=3; i++){ //using let getting new refrences
    setTimeout(()=>{
      console.log(i)
    }, 1000)
  }
}
hello() //0 1 2 3

function hello(){
  for(let i=0; i<=3; i++){ //alternative of let i.e closures and passing indexes
   function hi(i){
      setTimeout(()=>{
      console.log(i)
    }, 1000)
   }
   hi(i)
  }
}
hello() //0 1 2 3
=========================================================================================================================================================================
//move zeroes

function moveZeroes(arr){
  for(let i=0; i<arr.length; i++){
    if(arr[i] === 0){
      arr.push(0);
      arr.splice(i,1)
    }
  }
  return arr
}
console.log(moveZeroes([0,2,3,0,50,0,3,0,8,2,0]))
=======================================================================================================================================================================
function sumofTwopair(arr, target){
  for(let i=0; i<arr.length; i++){
   for(let j=i+1; j<arr.length; j++){
     if(arr[i]+arr[j] === target) return true
   }
  }
  return false
}
console.log(sumofTwopair([0,22,3,0,50,0,3,0,8,2,0],5))
--------------------------------------------------------
function sumofTwopair(arr, target){
  let s = new Set();
  for(let item of arr){
    if(s.has(target-item)){
      return true
    }else{
      s.add(item)
    }
  }
  return false
}
console.log(sumofTwopair([0,2,3,0,50,0,3,0,8,2,0],5))
=======================================================================================================================================================================
Polyfill of Flat:
function flatArray(arr){
  let result = arr.reduce((accum, item)=>{
    Array.isArray(item) 
    ? accum.push(...flatArray(item))
    : accum.push(item);
    return accum
  },[])
  return result;
}
console.log(flatArray([1,2,3,[4,[5,[6,7,[8]]]]]))
=======================================================================================================================================================================
Merge 2 sorted array:
function mergedTwoArrays(arr1,arr2){
   let mergedArray= [];
   let i = 0, j=0;
   while((i < arr1.length)&&(j< arr2.length)){
     if(arr1[i]<arr2[j]){
         mergedArray.push(arr1[i]);
         i++;  
      }
      else{
         mergedArray.push(arr2[j]);
         j++;
      }   
    }
   if(i<=(arr1.length-1)){    
     arr1.splice(0,i);
     mergedArray=mergedArray.concat(arr1);
   }
   else if(j<=(arr2.length-1)){
     arr2.splice(0,j);
     mergedArray=mergedArray.concat(arr2);  
   }
   return mergedArray;
}
console.log(mergedTwoArrays([1,2,3,4], [2,5,6]))
-----------------------------------------------------
function mergedTwoArrays(arr1,arr2){
  let result= [], i=0, j=0;
  while(i < arr1.length && j< arr2.length){
     if(arr1[i]<arr2[j]){
         result.push(arr1[i]); i++;
      }
      else{
         result.push(arr2[j]); j++;
      }   
   }
   while(i < arr1.length){    
         result.push(arr1[i]); i++;
   }
   while(j< arr2.length){ 
         result.push(arr2[j]); j++;
   }
   return result;
}
console.log(mergedTwoArrays([1,2,3,4], [2,5,6]))
=======================================================================================================================================================================

=======================================================================================================================================================================
********************Implementation of Currying*****************
  
//fn is pointing to sum function, i.e (a,b,c,d) => a+b+c+d.
function currying(fn){
  //args is pointing to (1)(2)(3)(4)(5)
  return function curry(...args){ //1 //2 //3 //4
    //when length get matched, then add all the values
    if(args.length >= fn.length) return fn(...args);
    else{
      return function(...next){
        return curry(...args, ...next)
      }
    }
  }
}
const sum = (a,b,c,d) => a+b+c+d;
const totalSum = currying(sum)
console.log(totalSum(1)(2)(3)(4))
=======================================================================================================================================================================
Destructuring in nested object:

const obj = {
  name : "John",
  address : {
    country : "India",
    add : {
      city : "Delhi"
    }
  }
}

const {address} = obj;
console.log(address) //{country : "India", "add": {"city" : "India"}}

const {address:{country}} = obj;
console.log(country) //India

const {address:{add:{city}}} = obj;
console.log(city) //Delhi
=======================================================================================================================================================================


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Dassault Systems:
const inputArray = ["INDIA:[Delhi,Mumbai,Chennai]"]; //1
const extepctedOutputArray = ["INDIA:[Delhi]", "OR", "INDIA:[Mumbai]", "OR", "INDIA:[Chennai]"];


//GENERIC JS FUNCTION --> String with  comma will split as separate Items in new ARRAY and separated with OR between each

function convertToORBasedExpression (arr){
 var outputArray =[];
 var temp = arr[0].split(":")[1]; //"[Delhi,Mumbai,Chennai]"
 var tmp = temp.slice(1,21).split(",") //["Delhi","Mumbai","Chennai"]
 for (let item of tmp){
   //console.log("INDIA:"+item)
   outputArray.push("INDIA:"+item)
 }
// console.log(temp.slice(1,21).split(","))
  
 return outputArray; //5
}
convertToORBasedExpression(inputArray)
